import os, subprocess
import threading
import time
import random
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import tools.fileHandler as fh	
import concurrent.futures
from timeit import timeit
class swarmulator:
	def __init__(self, path="../swarmulator",verbose=True):
		self.path = path
		self.verbose = verbose
		
	def make(self, controller=None, agent=None, animation=False, logger=False, verbose=False, speed=True, clean=False):
		spd = " -j" if speed else ""
		ani = " ANIMATION=ON" if animation else ""
		log = " LOG=ON" if logger else ""
		vrb = " VERBOSE=ON" if verbose else ""
		ctrl = " CONTROLLER="+controller if controller else ""
		agnt = " AGENT="+agent if controller else ""
		if clean:
			subprocess.call("cd " + self.path + " && make clean ", shell=True)
		subprocess.call("cd " + self.path + " && make" + spd + ani + log + vrb + ctrl + agnt, shell=True)
		print("# Done")

	def launch(self, n, run_id=1):
		subprocess.call("cd " + self.path + " && ./swarmulator " + str(n) + " " + str(run_id) + " &>/dev/null", shell=True)
		if self.verbose: print("Launched instance of swarmulator with %s robots and pipe ID %s" % (n,run_id))

	def get_fitness(self,pipe):
		while not os.path.lexists(pipe):
			time.sleep(0.1) # wait for swarmulator to complete and create the pipe
		f = open(pipe).read() # FIFO pipe generated by swarmulator
		if self.verbose: print("Received fitness %s from pipe %s" % (str(f),pipe))
		return f

	def run(self, n, run_id=None):
		self.run_id = random.randrange(100000) if run_id is None else run_id;
		self.run_id = str(self.run_id)
		pipe = str("/tmp/swarmulator_" + self.run_id)
		self.launch(n,run_id=self.run_id)
		f = self.get_fitness(pipe)
		return f

	def load(self,id=None):
		if id is not None:
			self.run_id = str(id) 
		else: # use latest
			file = fh.get_latest_file(self.path + "/logs/log_*.txt")
			st = file.find('_')
			end = file.find('.txt')
			self.run_id = file[st+1:end] # reconstruct id
		return np.loadtxt(self.path + "/logs/log_" + self.run_id + ".txt")

	def plot_log(self, id_column=1, time_column=0, x_column=2, y_column=3):
		data = self.load()
		robots = int(data[:,id_column].max())
		if self.verbose: print("Total number of robots: " + str(robots))
		fig = plt.figure()
		ax = fig.gca(projection='3d')
		for x in range(1,robots):
			d = data[np.where(data[:,id_column] == x)]
			ax.plot(d[:,time_column],d[:,x_column],d[:,y_column])
		ax.set_xlabel("Time [s]")
		ax.set_ylabel("N [m]")
		ax.set_zlabel("E [m]")
		plt.show()

	# def animate_log(self, id_column=1, time_column=0, x_column=2, y_column=3):
	# 	data = self.load()
	# 	robots = int(data[:,id_column].max())
	# 	print("Total number of robots: " + str(robots))
	# 	fig = plt.figure()
	# 	ax = fig.gca(projection='3d')
	# 	t = np.unique(data[:,time_column])
	# 	fitness = np.zeros(t.shape)
	# 	for step in t:
	# 		for x in range(1,robots):
	# 			d = data[np.where(data[:,id_column] == x)]
	# 			ax.plot(d[:,x_column],d[:,y_column])
	# 		ax.set_ylabel("N [m]")
	# 		ax.set_zlabel("E [m]")
	# 		plt.show()

	def runtime_setting(self, setting, value):
		s = "xmlstarlet edit -L -u \"/parameters/" + setting + "\" -v \""+ value + "\" " + self.path + "/conf/parameters.xml"
		subprocess.call(s, shell=True)
		if self.verbose: print("Runtime setting \"" + setting + "\" has been set to \"" + value + "\"")

	def get_runtime_setting(self, setting):
		s =  "xmlstarlet sel -t -v" +  " \"parameters/" +setting + "\" "+ self.path + "/conf/parameters.xml"
		value = subprocess.getoutput(s)
		if self.verbose: print("Runtime setting \"" + setting + "\" is \"" + value + "\"")
		return value;

	def batch_run(self,n,runs):
		if isinstance(n,int): 
			robots = np.repeat(n,runs)
		elif len(n) == 2: 
			robots = np.random.randint(n[0],n[1],runs)
		
		if runs == 1:
			print("WARNING: Running simulator.batch_run but only using 1 run. Consider just using swarmulator.run instead")
		
		out = np.zeros(runs)
		c = 0
		with concurrent.futures.ProcessPoolExecutor() as executor:
			for i, f in zip(robots,executor.map(self.run, robots)):
				out[c] = float(f)
				c += 1
		return out